<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Auto Trading Bot with Live Chart</title>

  <!-- Lightweight Charts CDN -->
  <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background:#f7f8fb; color:#222; }
    #container { display:flex; gap:20px; }
    #left { flex:1; min-width:520px; }
    #right { width:360px; }
    #chart { height: 480px; background:#fff; border:1px solid #ddd; }
    select, input, button { width:100%; margin:8px 0; padding:8px; font-size:14px; }
    button { cursor:pointer; border:none; background:#1976d2; color:#fff; }
    button.secondary { background:#666; }
    pre { background:#fff; border:1px solid #ddd; padding:10px; height:240px; overflow:auto; }
    .stat { background:#fff; border:1px solid #ddd; padding:8px; margin-bottom:8px; }
    .small { font-size:13px; color:#555; }
  </style>
</head>
<body>
  <h2>Auto Trading Bot â€” Live Chart + Trade</h2>
  <div id="container">
    <div id="left">
      <div id="chart"></div>
    </div>

    <div id="right">
      <div class="stat">
        <label for="symbols">Symbol</label>
        <select id="symbols"></select>
        <div class="small">Chart timeframe: 1 minute (kline_1m). Change in dropdown then click "Load Chart".</div>
        <button id="loadChart">Load Chart</button>
      </div>

      <div class="stat">
        <label for="budget">Budget (USDT)</label>
        <input id="budget" type="number" value="10" step="0.1" />
        <label for="sl">Stop-loss (%)</label>
        <input id="sl" type="number" value="5" step="0.1" />
        <label for="tp">Take-profit (%)</label>
        <input id="tp" type="number" value="20" step="0.1" />
        <button id="start" style="margin-top:8px">Start Auto Trade</button>
        <button id="stop" class="secondary">Stop Bot</button>
      </div>

      <div class="stat">
        <strong>Status</strong>
        <div id="status">idle</div>
      </div>

      <div class="stat">
        <strong>Position / Logs</strong>
        <pre id="log">No trades yet.</pre>
      </div>
    </div>
  </div>

  <script>
    // --- CONFIG ---
    // Public Binance websocket base for mainnet:
    const BINANCE_WSS = 'wss://stream.binance.com:9443/ws';
    // For testnet market data use: 'wss://testnet.binance.vision/ws' (uncomment if using testnet market data)
    // const BINANCE_WSS = 'wss://testnet.binance.vision/ws';

    // default symbol to include (XRP)
    const DEFAULT_SYMBOL = 'XRPUSDT';

    // --- UI refs ---
    const sel = document.getElementById('symbols');
    const loadChartBtn = document.getElementById('loadChart');
    const budgetInput = document.getElementById('budget');
    const startBtn = document.getElementById('start');
    const stopBtn = document.getElementById('stop');
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');

    // --- Chart setup (lightweight-charts) ---
    const chartContainer = document.getElementById('chart');
    chartContainer.innerHTML = '';
    const chart = LightweightCharts.createChart(chartContainer, {
      width: chartContainer.clientWidth,
      height: 480,
      layout: { backgroundColor: '#ffffff', textColor: '#111' },
      grid: { vertLines: { color: '#eee' }, horzLines: { color: '#eee' } },
      rightPriceScale: { visible: true }
    });
    const candleSeries = chart.addCandlestickSeries();

    // Resize handling
    window.addEventListener('resize', () => {
      chart.applyOptions({ width: chartContainer.clientWidth });
    });

    // --- Helper: log ---
    function log(msg, replace=false) {
      const time = new Date().toLocaleTimeString();
      if (replace) {
        logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
      } else {
        logEl.textContent = `[${time}] ${msg}\n` + logEl.textContent;
      }
    }

    // --- Load available symbols from backend, but always add XRPUSDT first ---
    async function loadSymbols() {
      sel.innerHTML = '';
      const x = document.createElement('option');
      x.value = DEFAULT_SYMBOL;
      x.textContent = DEFAULT_SYMBOL + ' (XRP/USDT)';
      sel.appendChild(x);

      try {
        const r = await fetch('/symbols'); // expects your backend to expose /symbols
        const data = await r.json();
        data.forEach(s => {
          if (s.symbol !== DEFAULT_SYMBOL) {
            const o = document.createElement('option');
            o.value = s.symbol;
            o.textContent = s.symbol + ' (' + s.base + '/' + s.quote + ')';
            sel.appendChild(o);
          }
        });
      } catch (err) {
        log('Could not load symbols from backend: ' + err.message);
      }
    }

    // --- Live kline via Binance websocket ---
    let ws = null;
    let currentSymbol = DEFAULT_SYMBOL.toLowerCase(); // e.g. xrpusdt
    let klineInterval = '1m'; // use 1 minute klines
    let lastKline = null;

    function startKlineStream(symbol) {
      stopKlineStream();
      currentSymbol = symbol.toLowerCase();
      const streamName = `${currentSymbol}@kline_${klineInterval}`;
      const wssUrl = `${BINANCE_WSS}/${streamName}`;
      ws = new WebSocket(wssUrl);

      ws.onopen = () => {
        log(`Connected to ${streamName}`, true);
        statusEl.textContent = 'chart streaming';
      };

      ws.onmessage = (evt) => {
        try {
          const data = JSON.parse(evt.data);
          // kline object:
          const k = data.k;
          const candlestick = {
            time: Math.floor(k.t / 1000),
            open: parseFloat(k.o),
            high: parseFloat(k.h),
            low: parseFloat(k.l),
            close: parseFloat(k.c),
          };
          lastKline = candlestick;

          // upsert or update last bar
          candleSeries.update(candlestick);
          // if k.x === true -> kline closed, we may want to do decisions on close
          if (k.x) {
            // closed candle - good place for strategy decision if you run logic in frontend.
            log(`${symbol} closed candle @ ${k.c}`, true);
          }
        } catch (e) {
          console.error('ws parse err', e);
        }
      };

      ws.onerror = (e) => {
        console.error('ws err', e);
        log('WebSocket error');
        statusEl.textContent = 'ws error';
      };

      ws.onclose = () => {
        log('WebSocket disconnected');
        statusEl.textContent = 'idle';
      };
    }

    function stopKlineStream() {
      if (ws) {
        try { ws.close(); } catch(e) {}
        ws = null;
      }
    }

    // When user clicks Load Chart
    loadChartBtn.addEventListener('click', () => {
      const s = sel.value || DEFAULT_SYMBOL;
      // Clear existing series and reset chart (lightweight will update)
      candleSeries.setData([]); // clear
      // Optionally fetch recent historical klines to populate initial view
      fetchHistoricalKlines(s, klineInterval).then(bars => {
        if (bars && bars.length) {
          candleSeries.setData(bars);
        }
        startKlineStream(s);
      }).catch(err => {
        log('Failed to load historical klines: ' + err.message);
        startKlineStream(s);
      });
    });

    // --- Fetch recent klines (use backend proxy to avoid CORS or use Binance public REST if CORS allowed) ---
    async function fetchHistoricalKlines(symbol, interval) {
      // Prefer backend route '/klines?symbol=...&interval=...' implemented on your node backend
      try {
        const r = await fetch(`/klines?symbol=${encodeURIComponent(symbol)}&interval=${interval}`);
        if (!r.ok) throw new Error('klines fetch failed');
        const data = await r.json(); // expects array of { time, open, high, low, close }
        return data;
      } catch (err) {
        // fallback: try Binance public REST (may be blocked by CORS)
        try {
          const resp = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=150`);
          if (!resp.ok) throw new Error('binance rest failed');
          const arr = await resp.json();
          return arr.map(a => ({
            time: Math.floor(a[0] / 1000),
            open: parseFloat(a[1]),
            high: parseFloat(a[2]),
            low: parseFloat(a[3]),
            close: parseFloat(a[4])
          }));
        } catch(e) {
          throw e;
        }
      }
    }

    // --- Bot control: Start/Stop trading (trades executed on backend) ---
    startBtn.addEventListener('click', async () => {
      const symbol = sel.value || DEFAULT_SYMBOL;
      const budgetUSDT = parseFloat(budgetInput.value);
      const sl = parseFloat(document.getElementById('sl').value);
      const tp = parseFloat(document.getElementById('tp').value);

      if (!budgetUSDT || budgetUSDT <= 0) { alert('Enter a valid budget'); return; }
      statusEl.textContent = 'starting trade...';
      log(`Requesting backend to buy ${symbol} with ${budgetUSDT} USDT (SL ${sl}%, TP ${tp}%)`);

      try {
        const res = await fetch('/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ symbol, budgetUSDT, stopPercent: sl, takeProfitPercent: tp })
        });
        const data = await res.json();
        if (!res.ok) {
          throw new Error(JSON.stringify(data));
        }
        log('Trade started: ' + JSON.stringify(data));
        statusEl.textContent = 'position open';
      } catch (err) {
        console.error(err);
        log('Error starting trade: ' + err.message);
        statusEl.textContent = 'error';
      }
    });

    stopBtn.addEventListener('click', async () => {
      try {
        await fetch('/stop', { method: 'POST' });
        statusEl.textContent = 'stopped';
        log('Bot stopped (requested backend).');
      } catch (err) {
        log('Stop failed: ' + err.message);
      }
    });

    // Initialize UI
    loadSymbols();
    // auto-load chart for DEFAULT_SYMBOL
    window.addEventListener('load', () => {
      sel.value = DEFAULT_SYMBOL;
      loadChartBtn.click();
    });
  </script>
</body>
</html>
